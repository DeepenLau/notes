### 千聊

1. jwt 的使用过程

2. 项目遇到的难点

3. 浏览器有什么线程

   - GUI 渲染线程
   
     `GUI渲染线程`负责渲染浏览器界面HTML元素,当界面需要重绘(Repaint)或由于某种操作引发回流(reflow)时,该线程就会执行。在Javascript引擎运行脚本期间,GUI渲染线程都是处于挂起状态的,也就是说被”冻结”了.
   
   - JavaScript引擎线程

     Javascript是单线程的, 那么为什么Javascript要是单线程的？
   
     这是因为Javascript这门脚本语言诞生的使命所致：JavaScript为处理页面中用户的交互，以及操作DOM树、CSS样式树来给用户呈现一份动态而丰富的交互体验和服务器逻辑的交互处理。如果JavaScript是多线程的方式来操作这些UI DOM，则可能出现UI操作的冲突； 如果Javascript是多线程的话，在多线程的交互下，处于UI中的DOM节点就可能成为一个临界资源，假设存在两个线程同时操作一个DOM，一个负责修改一个负责删除，那么这个时候就需要浏览器来裁决如何生效哪个线程的执行结果。当然我们可以通过锁来解决上面的问题。但为了避免因为引入了锁而带来更大的复杂性，Javascript在最初就选择了单线程执行。
   
   - 定时触发器线程
   
     浏览器定时计数器并不是由JavaScript引擎计数的, 因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确, 因此通过单独线程来计时并触发定时是更为合理的方案。
   
   - 事件触发线程
   
     当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。这些事件可以是当前执行的代码块如定时任务、也可来自浏览器内核的其他线程如鼠标点击、AJAX异步请求等，但由于JS的单线程关系所有这些事件都得排队等待JS引擎处理。
   
   - 异步http请求线程
   
     在XMLHttpRequest在连接后是通过浏览器新开一个线程请求， 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到 JavaScript引擎的处理队列中等待处理。
   
   > GUI 渲染线程 与 JavaScript引擎线程互斥
   
4. 宏任务和微任务机制

5. requestAnimationFrame 在什么时候执行 

   GUI线程，微任务之后，宏任务之前

6. 做过哪些 webpack 的优化

   - 资源压缩
   - 资源合并
   - tree shaking
   - 添加 content hash 持久化缓存
   - 提取公用模块

7. tree shaking 基于什么实现的

   基于 ES6 Module 静态分析，故而编译的时候正确判断到底加载了那些模块

   静态分析程序流，判断那些模块和变量未被使用或者引用，进而删除对应代码

8. es module 和 commonjs 有什么区别

   commonjs： 

   - 运行时加载
   - CommonJS 模块输出的是值的缓存，不存在动态更新
   - 导出语句 module.exports

   es module：

   - 编译时加载或者静态加载
   - 自动采用严格模式
   - `export`语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。
   - 导出语句 export defualt
   - import()

9. 实现一个 async / await

10. Map / Set

11. cookie 的属性 / Same site

    csrf 攻击 

    Cookie 往往用来存储用户的身份信息，恶意网站可以设法伪造带有正确 Cookie 的 HTTP 请求，这就是 CSRF 攻击。

    `SameSite`属性用来限制第三方 Cookie，从而减少安全风险

    `SameSite`三个值

    - Strict
    - Lax
    - None

12. http 缓存

    强缓存 / 协商缓存
    
13. 实现一个可控深度的数组扁平化
    
14. 斐波那契数列的优化

15. 斐波那契数列的应用（购物车）

16. eggjs 如何定义路由

17. eggjs 多进程模型

18. nuxtjs 用到的功能

19. ssr 脱水 / 注水

    在服务器端，当服务端请求接口拿到数据，并处理好数据状态(例如 `store`的更新)后，保留住这个状态，在服务器端响应页面`HTML`的时候，将这个状态一并传递给浏览器，这个过程，叫做**脱水**(`Dehydrate`)；在浏览器端，就直接拿这个**脱水**数据来初始化 `React`组件，也就是客户端不需要自己发起请求获取数据处理状态了，因为服务器端已经做好了这件事情，直接从服务器端那里获取处理好的状态即可，这个过程叫**注水**(`Hydrate`)

20. vue 2 / vue 3 区别

21. typescript 的范型的理解

22. Undefined 和 null 的区别

    - **null表示"没有对象"，即该处不应该有值**
    - **undefined表示"缺少值"，就是此处应该有一个值，但是还没有定义。**

23. Seo 优化 TDK（title description keyword）

24. BFC

25. 重排/重绘




---

1. nuxt 的模块机制plugin（mount 时机加载），middleware机制（注册路由钩子回调函数）

2. webpack loader / plugin 区别，执行时机

   loader，它是一个转换器，将A文件进行编译成B文件，比如：将A.less转换为A.css，单纯的文件转换过程。

   plugin是一个扩展器，它丰富了webpack本身，针对是loader结束后，webpack打包的整个过程，它并不直接操作文件，而是基于事件机制工作，会监听webpack打包过程中的某些节点，执行广泛的任务

   1. loader运行在打包文件之前（loader为在模块加载时的预处理文件）
   2. plugins在整个编译周期都起作用。

1. vuex 实现机制

----

shopline

1. dom tree 生成的时候，在dom中间的script对dom操作，会发生什么

   答：中断GUI线程的渲染，执行javascript代码，可以修改这段代码前的dom，修改后面的话会报错

2. 如果这段代码删除一个dom，会不会重新计算生成 dom tree

   懵了

3. 浏览器内存管理机制，回收机制，回收过程是怎样的

   分为两个部分：栈内存，堆内存

   - 栈内存
     - 空间较小 1 ～8m
     - 存储一些基本类型值，和代码字符串
     - 堆内存的引用地址
   - 堆内存
     - 空间较大
     - 存储引用类型值

   垃圾回收过程：

   栈内存的垃圾回收：

   - 通过在执行栈中的执行上下文切换的时候释放，ESP （执行状态指针）下移的时候释放

   堆内存垃圾回收：

   - 新生代（副垃圾回收器）
     - 空间较小
     - 存放存活时间短的活动对象
     - 分为两个区域：对象区域，空闲区域
       - 新加入的对象放入对象区域，当快写满时，进行垃圾标记，把存活的对象有序地复制进空闲区域，然后清空对象区域
       - 然后对象区域和空闲区域进行反转，角色互换，这样这两个区域就可以无限重复使用下去
       - 复制需要时间，如果新生代设置空间过大，复制就会耗时间，清理时间就会久，造成页面卡顿
     - 由于空间不大，经过两次回收的对象仍然存活，就会触发对象晋升策略，把该对象移动到老生代区中
   - 老生代（主垃圾回收器）
     - 存储的对象特点：占用空间大(直接声明的大对象)，对象存活时间长(新生代区晋升而来的)
     - 标记 - 清除算法
       - ESP 向下移动的时候扫描执行调用栈，没有被引用的对象会被标记成红色，然后清除
       - 这样会造成内存中大量不连续的内存碎片，会导致后面无法分配足够的连续内存
     - 标记 - 整理算法
       - 标记过程和上面一样
       - 不是清除标记为红色的对象，而是把存活对象向一端移动，然后清楚这一端边界以外的内存
     - 全停顿（Stop-The-World）/ 增量标记算法
       - 每次垃圾回收都会暂停JavaScript是执行，如果内存中数据过大，则导致暂停过久，造成卡顿
       - 把标记的的过程拆分为子标记任务，和javascript的执行交替进行，直到标记结束，最后一并回收

4. 生成器函数解决回调

   不断自执行

5. 性能优化没有体系化，没有电商经验

